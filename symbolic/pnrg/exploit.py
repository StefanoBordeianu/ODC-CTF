import z3

seed = z3.BitVec("seed", 32)
state = [0]*10016

def m_seedRand(state, seed):
    state[0] = seed & 0xffffffff
    index = 1
    while (index < 0x270):
        state[index] = state[index - 1] * 0x17b5
        index = index + 1

magV = 0xdfb0089900000000
def mag(uVar2):
   if uVar2 == 0:
      return 0
   else:
      return magV

def seedRand(state, seed):
  local_1398 = [0]*625
  
  bVar4 = 0
  m_seedRand(local_1398,seed)
  puVar2 = 0
  puVar3 = 0
  for lVar1 in range(0x271,0,-1):
    state[puVar3] = local_1398[puVar2]
    puVar2 = puVar2 + bVar4 * -2 + 1
    puVar3 = puVar3 + bVar4 * -2 + 1

  return state


def genRandLong():  
  index = 0
  if ((0x26f < index) or index < 0):
    if ((0x270 < index) or index < 0):
       m_seedRand(state,0x1105)
    for index in range(0xe3):
       uVar2 = state[index + 1] & 1
       state[index] = state[index + 0x18d] ^ (z3.LShR(uVar2 & 0x7fffffff | state[index] & 0x80000000)) ^ mag(uVar2)

    for index in range(0xe3, 0x26f):
       uVar2 = state[index + 1] & 1
       state[index] = state[index + -0xe3] ^ (z3.LShR(uVar2 & 0x7fffffff | state[index] & 0x80000000)) ^ mag(uVar2)

    uVar2 = state[0] & 1
    state[0x26f] = state[0x18c] ^ (z3.LShR(uVar2 & 0x7fffffff | state[0x26f] & 0x80000000)) ^ mag(uVar2)
    index = 0
  uVar2 = index
  index = uVar2 + 1
  uVar1 = state[uVar2] ^ state[uVar2] << 0xb 
  uVar1 = uVar1 ^ (uVar1 << 7) & 0x9d2c5680
  uVar1 = uVar1 ^ (uVar1 << 0xf) & 0xefc60000
  return z3.LShR(uVar1 ^ uVar1, 0x12)



def challenge():
   global state
   state = seedRand(state,seed)

   for i in range(1000):
      genRandLong()
   return genRandLong()
   

solver = z3.Solver()
solver.add(challenge() == 0x38f96792)
print(solver.check())
m = solver.model()



print(m)
