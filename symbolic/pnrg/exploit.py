import z3

def m_seedRand(state, seed):
    state[0] = seed & 0xffffffff
    index = 1
    while (index < 0x270):
        state[index] = state[index - 1] * 0x17b5
        index = index + 1

mag = 0xdfb0089900000000

def genRandLong(state):  
  index = 0
  if ((0x26f < index) or index < 0):
    if ((0x270 < index) or index < 0):
       m_seedRand(state,0x1105)
    for index in range(0xe3):
       uVar2 = state[index + 1]
       state[index] = state[index + 0x18d] ^ (z3.LShR(uVar2 & 0x7fffffff | state[index] & 0x80000000)) ^ (mag + (uVar2 & 1) * 8)

    for index in range(0xe3, 0x26f):
       uVar2 = state[index + 1]
       state[index] = state[index + -0xe3] ^ (z3.LShR(uVar2 & 0x7fffffff | state[index] & 0x80000000)) ^ (mag +(uVar2 & 1) * 8)

    uVar2 = state[0]
    state[0x26f] = state[0x18c] ^ (z3.LShR(uVar2 & 0x7fffffff | state[0x26f] & 0x80000000)) ^ (mag + (uVar2 & 1) * 8)
    index = 0
  uVar2 = index
  index = uVar2 + 1
  uVar1 = z3.LShL(state[uVar2] ^ state[uVar2],0xb) 
  uVar1 = uVar1 ^ z3.LShL(uVar1,7) & 0x9d2c5680
  uVar1 = uVar1 ^ z3.LShL(uVar1,0xf) & 0xefc60000
  return z3.LShR(uVar1 ^ uVar1, 0x12)


state = [0]*0x270
m_seedRand(state, z3.BitVec("seed", 32))
genRandLong(state)


print(state[2])
